(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{274:function(e,t,r){"use strict";r.r(t);var s=r(2),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue-router"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[e._v("#")]),e._v(" Vue Router")]),e._v(" "),r("h2",{attrs:{id:"路由简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由简介"}},[e._v("#")]),e._v(" 路由简介")]),e._v(" "),r("ul",[r("li",[e._v("传统的路由指的是：当用户访问一个 url 时，对应的服务器会接收这个请求，然后解析 url 中的路径，从而执行对应的处理逻辑。这样就完成了一次路由分发。")]),e._v(" "),r("li",[e._v("而前端路由是不涉及服务器的，是前端利用 hash 或者 HTML5 的 history API 来模拟实现的，一般用于不同内容的展示和切换。")]),e._v(" "),r("li",[e._v("目前 Vue 推荐单页面应用 SPA 开发模式，大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。Vue 中的路由解决方案为 vue-router。")])]),e._v(" "),r("blockquote",[r("p",[e._v("Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。我们用 vue-cli 开发的项目就是单页面应用。\nvue 路由能实现哪些功能")])]),e._v(" "),r("ul",[r("li",[e._v("嵌套的路由/视图表")]),e._v(" "),r("li",[e._v("模块化的、基于组件的路由配置")]),e._v(" "),r("li",[e._v("路由参数、查询、通配符")]),e._v(" "),r("li",[e._v("基于 Vue.js 过渡系统的视图过渡效果")]),e._v(" "),r("li",[e._v("细粒度的导航控制")]),e._v(" "),r("li",[e._v("带有自动激活的 CSS class 的链接")]),e._v(" "),r("li",[e._v("HTML5 历史模式或 hash 模式，在 IE9 中自动降级")]),e._v(" "),r("li",[e._v("自定义的滚动条行为")])]),e._v(" "),r("h2",{attrs:{id:"路由安装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由安装"}},[e._v("#")]),e._v(" 路由安装")]),e._v(" "),r("p",[e._v("我们在 vue-cli 创建项目的时候就默认安装路由")]),e._v(" "),r("h2",{attrs:{id:"手动安装-vue-路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#手动安装-vue-路由"}},[e._v("#")]),e._v(" 手动安装 vue 路由")]),e._v(" "),r("blockquote",[r("p",[e._v("这一步是安装路由 保存到我们 package.json 里面的 dependencies 里面")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("npm install vue-router --save\n")])])]),r("h2",{attrs:{id:"路由起步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由起步"}},[e._v("#")]),e._v(" 路由起步")]),e._v(" "),r("blockquote",[r("p",[e._v("配置路由文件")])]),e._v(" "),r("ol",[r("li",[e._v("在 main.js 的同级目录新建一个 router 的文件夹(这个文件夹存放的是我们路由的配置文件)")]),e._v(" "),r("li",[e._v("在这个文件夹下创建 index.js 里面写上")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n// 上面三个是引入vue-router(你安装路由之后不引入相当于做无用功)\nexport default new Router({  // 把我们的路由配置文件暴露出去\n  mode: 'history',\n  // vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。如果不想/// 要很丑的 hash，我们可以用路由的 history 模式\n  routes: [  // 这个存放的是我们路由的配置文件\n\n  ]\n})\n\n")])])]),r("ol",{attrs:{start:"3"}},[r("li",[e._v("在 view 目录下新建两个文件夹 一个是 index 一个是 mine 这个文件夹代表两个页面(这个一个规范) 一个是 index 页面 一个是 mine 页面 分别在 mine 和 index 下面新建 index.vue (创建我们的组件) 里面分别写上内容 '首页' 'mine 页'\n"),r("img",{attrs:{src:"%22https://raw.githubusercontent.com/208895638/teachVue/master/%E6%88%AA%E5%9B%BE/vue%E7%9B%AE%E5%BD%95%E6%88%AA%E5%9B%BE.jpg%22",alt:"项目结构",title:"项目结构"}})]),e._v(" "),r("li",[e._v("在我们的 router 文件夹下的 index.js 里面引入我们的组件")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('import index from "@/views/index/index" // 引入index组件\nimport mine from "@/views/mine/index" // 引入mine组件\n')])])]),r("ol",{attrs:{start:"5"}},[r("li",[e._v("配置路由")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export default new Router({\n  mode: 'history',  // 启用history路由\n  routes: [ // 这里面是路由的配置项\n    {\n      path: '/',  // 这个是我们访问浏览器的地址\n      name: 'index',  // 这个是我们给路由起的名称\n      component: index  // 这个是 地址对应的组件\n    },\n    {\n      path: '/mine', // 这个是我们访问浏览器的地址\n      name: 'mine',  // 这个是我们给路由起的名称\n      component: mine  // 这个是 地址对应的组件\n    }\n  ]\n})\n")])])]),r("ol",{attrs:{start:"6"}},[r("li",[e._v("上一步就代表路由配置完成 我们需要把我们的路由配置挂载到我们的 vue 实例上 在 main.js 里面操作")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("import Vue from 'vue'\nimport App from './App.vue'\nimport router from './router/index'  // 引入我们刚刚配置的路由文件\nVue.config.productionTip = false\nnew Vue({\n  router, // 把路由挂载到vue实例上\n  render: h => h(App)\n}).$mount('#app')\n")])])]),r("ol",{attrs:{start:"7"}},[r("li",[e._v("最后一步 在我们的 app.vue 里面加一个组件 router-view")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<router-link to="/">跳转到首页</router-link>\n<router-link :to="{path:\'/\'}">跳转到首页</router-link>\n    <router-link to="/mine">跳转到mine页</router-link>\n\n    <router-view></router-view>\n')])])]),r("p",[e._v("router-view 这个组件是一个容器 我们页面的路由所对应的组件都渲染在这个容器里面\nrouter-link 是在 vue 里面做跳转链接用的 vue 会把 router-link 渲染成 a 标签")]),e._v(" "),r("ol",{attrs:{start:"8"}},[r("li",[e._v("好了 一个最基本的路由完成")])]),e._v(" "),r("h2",{attrs:{id:"自动激活的-css-class-的链接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自动激活的-css-class-的链接"}},[e._v("#")]),e._v(" 自动激活的 CSS class 的链接")]),e._v(" "),r("p",[e._v("当 router-link 里面的 to 地址与地址栏中的路由匹配一样时就自动激活 router-link-active")]),e._v(" "),r("p",[e._v("如\n当前路由为 /home 而"),r("router-link",{attrs:{to:"/home",exact:""}}),e._v(" router-link-active 这个 class 名称就会自动被激活")],1),e._v(" "),r("blockquote",[r("p",[e._v("自定义激活 class 名称 linkActiveClass")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("export default new Router({\n  mode: 'history',  // 启用history路由\n  linkActiveClass:\"r-active\",  // 这个就是设置激活是的class名称\n  routes: [ // 这里面是路由的配置项\n    {\n      path: '/',  // 这个是我们访问浏览器的地址\n      name: 'index',  // 这个是我们给路由起的名称\n      component: index  // 这个是 地址对应的组件\n    },\n  ]\n})\n")])])]),r("h2",{attrs:{id:"动态路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态路由"}},[e._v("#")]),e._v(" 动态路由")]),e._v(" "),r("blockquote",[r("p",[e._v("简介 我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：")])]),e._v(" "),r("ul",[r("li",[e._v("配置动态路由")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('{\n    path : "/mine/:id", // 动态路由\n    name : "mine" ,\n    component: mine\n}\n\n\n')])])]),r("p",[e._v("使用的时候 会自动匹配 1，2，3，4 到 mine 组件")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('<router-link to="/mine/1">跳转到mine页</router-link>\n<router-link to="/mine/2">跳转到mine页</router-link>\n<router-link to="/mine/3">跳转到mine页</router-link>\n<router-link to="/mine/4">跳转到mine页</router-link>\n<router-link :to="{name:\'mine\',params:{id:1}}">跳转到mine页</router-link>\n这里需要注意的一点就是 当路由是动态路由的时候我们得用命名路由的方式跳转\n')])])]),r("h2",{attrs:{id:"嵌套路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#嵌套路由"}},[e._v("#")]),e._v(" 嵌套路由")]),e._v(" "),r("blockquote",[r("p",[e._v("简介 实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("/user/profile                     /user/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------\x3e  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n")])])]),r("blockquote",[r("p",[e._v("嵌套路由的写法")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const router = new VueRouter({\n  routes: [\n    { path: '/user', component: User,redirect:\"/user/profile\"\n      children: [\n        {\n          // 当 /user/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: 'profile',\n          component: UserProfile\n        },\n        {\n          // 当 /user/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: 'posts',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n")])])]),r("h2",{attrs:{id:"编程式的导航"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编程式的导航"}},[e._v("#")]),e._v(" 编程式的导航")]),e._v(" "),r("p",[e._v("除了使用 "),r("code",[e._v('<router-link to=""></router-link>')]),e._v(" 创建 a 标签来定义导航链接 我们还可以用 js 的方法跳转页面")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n")])])]),r("h2",{attrs:{id:"命名路由"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#命名路由"}},[e._v("#")]),e._v(" 命名路由")]),e._v(" "),r("blockquote",[r("p",[e._v("简介\n有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。可以在创建 Router 实例的时候，在 routes 配置中给某个路由设置名称。")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\nrouter.push({ name: 'user', params: { userId: 123 }})\n")])])]),r("h2",{attrs:{id:"重定向"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重定向"}},[e._v("#")]),e._v(" 重定向")]),e._v(" "),r("blockquote",[r("p",[e._v("重定向 把地址重定向到某个路由 重定向”的意思是，当用户访问 /a 时，URL 将会被替换成 /b，然后匹配路由为 /b")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b' }\n  ]\n})\n")])])]),r("h2",{attrs:{id:"html5-history-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#html5-history-模式"}},[e._v("#")]),e._v(" html5 History 模式")]),e._v(" "),r("blockquote",[r("p",[e._v("简介 vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。")])]),e._v(" "),r("p",[e._v("如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。\n当使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！\n不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404。")]),e._v(" "),r("blockquote",[r("p",[e._v("解决方法\n在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);